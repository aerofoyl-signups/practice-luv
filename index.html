<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Graph Transformation Practice</title>

<style>
    body {
        background: #f5f5f5;
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        padding: 40px;
    }
    .container {
        width: 740px;
        background: white;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    h1 { text-align: center; margin-bottom: 20px; }

    #graphCanvas {
        border: 1px solid #444;
        background: #fff;
        cursor: pointer;
    }

    .buttons {
        margin-top: 15px;
        text-align: center;
    }

    button {
        padding: 10px 18px;
        margin: 8px;
        font-size: 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: #3498db;
        color: white;
    }
    button:hover { background: #217dbb; }

    #resultText {
        font-size: 18px;
        margin-top: 15px;
        text-align: center;
        font-weight: bold;
    }
</style>
</head>
<body>

<div class="container">
    <h1>Graph Transformation Practice</h1>

    <div id="questionBox">
        <h2>Question:</h2>
        <p id="questionText">Click "New Question" to begin!</p>
    </div>

    <canvas id="graphCanvas" width="600" height="400"></canvas>

    <div class="buttons">
        <button id="newQuestionBtn">New Question</button>
        <button id="clearBtn">Clear</button>
        <button id="joinBtn">Join Points</button>
        <button id="checkBtn">Check Answer</button>
    </div>

    <p id="resultText"></p>
</div>



<script>
/*******************************************
 * QUESTIONS WITH EXPECTED FUNCTIONS
 *******************************************/
const questions = [
    { q: "f(x)=x² → g(x)=f(x−3)", func: x => (x-3)**2 },
    { q: "f(x)=|x| → g(x)=2f(x)", func: x => 2*Math.abs(x) },
    { q: "f(x)=√x → g(x)=−f(x)", func: x => -(Math.sqrt(Math.max(x,0))) },
    { q: "f(x)=x² → g(x)=−3f(x+1)", func: x => -3*(x+1)**2 },
    { q: "f(x)=|x| → g(x)=f(2x−4)", func: x => Math.abs(2*x-4) },
    { q: "f(x)=√x → g(x)=4f(0.5(x+6))−2", func: x => 4*Math.sqrt(Math.max(0.5*(x+6),0))-2 },
    { q: "f(x)=x³ → g(x)=f(−x+5)", func: x => (-x+5)**3 },
    { q: "f(x)=sin x → g(x)=−2sin(3(x−π/4))+1", func: x => -2*Math.sin(3*(x-Math.PI/4))+1 },
    { q: "f(x)=1/x → g(x)=½ f(−(x+2)) − 3", func: x => 0.5*(1/(-x-2)) - 3 },
    { q: "f(x)=x² → g(x)=−(1/3)f(−2(x−4)) + 5", func: x => -(1/3)*((-2*(x-4))**2) + 5 },
    { q: "f(x)=|x| → g(x)=−4 f((x+9)/3)", func: x => -4*Math.abs((x+9)/3) },
    { q: "f(x)=sin x → g(x)=3 sin(−½(x+2π)) − 4", func: x => 3*Math.sin(-0.5*(x+2*Math.PI)) - 4 }
];

let currentFunc = null;



/*******************************************
 * CANVAS + GRID SETUP
 *******************************************/
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");

const gridSize = 20;
let userPoints = [];

function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "#e0e0e0";
    ctx.lineWidth = 1;

    // Vertical grid lines
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }

    // Horizontal grid lines
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 2;

    // x-axis
    ctx.beginPath();
    ctx.moveTo(0, canvas.height/2);
    ctx.lineTo(canvas.width, canvas.height/2);
    ctx.stroke();

    // y-axis
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 0);
    ctx.lineTo(canvas.width/2, canvas.height);
    ctx.stroke();
}

function clearCanvas() {
    userPoints = [];
    drawGrid();
}

function snap(v) {
    return Math.round(v / gridSize) * gridSize;
}

function pxToMath(pxX, pxY) {
    let x = (pxX - canvas.width/2) / gridSize;
    let y = -(pxY - canvas.height/2) / gridSize;
    return [x, y];
}

function mathToPx(x, y) {
    return [
        x * gridSize + canvas.width/2,
        -y * gridSize + canvas.height/2
    ];
}



/*******************************************
 * POINT ADDING BY CLICKING
 *******************************************/
canvas.addEventListener("click", e => {
    let x = snap(e.offsetX);
    let y = snap(e.offsetY);

    // store math point
    let mathPt = pxToMath(x, y);
    userPoints.push(mathPt);

    // draw point
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fill();
});



/*******************************************
 * JOIN POINTS (Smooth Curve)
 * Catmull-Rom Spline
 *******************************************/
function drawSmoothCurve() {
    if (userPoints.length < 3) return;

    drawGrid(); // redraw grid
    drawUserPoints();

    // Sort points by x
    userPoints.sort((a,b) => a[0] - b[0]);

    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.beginPath();

    for (let i = 0; i < userPoints.length - 1; i++) {
        let p0 = userPoints[i-1] || userPoints[i];
        let p1 = userPoints[i];
        let p2 = userPoints[i+1];
        let p3 = userPoints[i+2] || p2;

        for (let t = 0; t < 1; t += 0.05) {
            let x = catmullRom(p0[0], p1[0], p2[0], p3[0], t);
            let y = catmullRom(p0[1], p1[1], p2[1], p3[1], t);

            let [px, py] = mathToPx(x, y);

            if (t === 0 && i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
    }

    ctx.stroke();
}

function catmullRom(p0, p1, p2, p3, t) {
    return 0.5 * ( 
        (2*p1) +
        (-p0 + p2) * t +
        (2*p0 - 5*p1 + 4*p2 - p3) * t*t +
        (-p0 + 3*p1 - 3*p2 + p3) * t*t*t
    );
}

function drawUserPoints() {
    for (let [x,y] of userPoints) {
        let [px,py] = mathToPx(x,y);
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI*2);
        ctx.fill();
    }
}



/*******************************************
 * NEW QUESTION
 *******************************************/
function newQuestion() {
    let index = Math.floor(Math.random() * questions.length);
    document.getElementById("questionText").textContent = questions[index].q;
    currentFunc = questions[index].func;

    document.getElementById("resultText").textContent = "";
    clearCanvas();
}



/*******************************************
 * CHECK ANSWER
 *******************************************/
function checkAnswer() {
    if (!currentFunc) return;

    if (userPoints.length < 3) {
        document.getElementById("resultText").textContent =
            "Add more points first!";
        return;
    }

    let errors = 0;

    for (let [x, y] of userPoints) {
        let expected = currentFunc(x);
        if (!isFinite(expected)) continue;

        if (Math.abs(expected - y) > 0.8) errors++;
    }

    if (errors < userPoints.length * 0.2) {
        document.getElementById("resultText").textContent =
            "✅ Good! Your curve matches the expected function.";
    } else {
        document.getElementById("resultText").textContent =
            "❌ Not close enough. Try adjusting your points.";
    }
}



/*******************************************
 * BUTTON HOOKS
 *******************************************/
document.getElementById("newQuestionBtn").onclick = newQuestion;
document.getElementById("clearBtn").onclick = clearCanvas;
document.getElementById("joinBtn").onclick = drawSmoothCurve;
document.getElementById("checkBtn").onclick = checkAnswer;

// initialize
clearCanvas();
</script>

</body>
</html>
